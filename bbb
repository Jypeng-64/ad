import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
from torch.utils.data import DataLoader,Dataset
from torchvision.datasets import ImageFolder
import pandas as pd
import os
from PIL import Image

Define hyperparameters
batch_size = 64
num_epochs = 10
lr = 0.0001

device = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')

train_transforms=transforms.Compose([
transforms.Resize((256, 256)),
transforms.CenterCrop((256, 256)),
transforms.ToTensor(),
transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])

Custom dataset class
class CustomDataset(Dataset):
def init(self, csv_file, root_dir, transform=None):
self.annotations = pd.read_csv(csv_file)
self.root_dir = root_dir
self.transform = transform
self.annotations.iloc[:,1] = self.annotations.iloc[:,1].apply(lambda x:0 if x == -1 else x)

stylus
Copy
def __len__(self):
    return len(self.annotations)

def __getitem__(self, index):
    img_path = os.path.join(self.root_dir, self.annotations.iloc[index, 0])
    image = Image.open(img_path).convert('RGB')
    label = self.annotations.iloc[index, 1]
    if self.transform:
        image = self.transform(image)

    return image, label
Load custom dataset
train_dataset = CustomDataset(csv_file='/home/DataBase1/jyp/mini-imagenet/trainall.csv', root_dir='/home/DataBase1/jyp/mini-imagenet/images/', transform=train_transforms)

定义数据集
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True, num_workers=4)

定义 teacher 网络
class TeacherNet(nn.Module):
def init(self):
super(TeacherNet, self).init()
self.conv1 = nn.Conv2d(3, 128, kernel_size=4, stride=1, padding=3)
self.pool1 = nn.AvgPool2d(kernel_size=2, stride=2, padding=1)
self.conv2 = nn.Conv2d(128, 256, kernel_size=4, stride=1, padding=3)
self.pool2 = nn.AvgPool2d(kernel_size=2, stride=2, padding=1)
self.conv3 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)
self.conv4 = nn.Conv2d(256, 384, kernel_size=4, stride=1)
self.pool3 = nn.AdaptiveAvgPool2d((1,1))
self.fc = nn.Linear(384,19)
def forward(self, x):
x = nn.functional.relu(self.conv1(x))
x = self.pool1(x)
x = nn.functional.relu(self.conv2(x))
x = self.pool2(x)
x = nn.functional.relu(self.conv3(x))
x = self.conv4(x)
x = self.pool3(x)
x = x.view(x.size(0),-1)
x = self.fc(x)
#print(x.size())
return x

定义优化器和损失函数
teacher_net = TeacherNet()
teacher_net = teacher_net.to(device)

optimizer = optim.Adam(teacher_net.parameters(), lr=lr,weight_decay=0.00001)
criterion = nn.CrossEntropyLoss()
#criterion = nn.functional.mse_loss()

数据集上训练 teacher 网络
for epoch in range(num_epochs):
for i, (images, labels) in enumerate(train_loader):
images = images.to(device)
labels = labels.to(device)
optimizer.zero_grad()
outputs = teacher_net(images)
#print(outputs.size(), labels.size())
loss = criterion(outputs.view(-1,19),labels.view(-1))
loss.backward()
optimizer.step()
if (i+1) % 100 == 0:
print('Epoch [{}/{}], Step [{}/{}], Loss: {:.8f}'.format(epoch+1, num_epochs, i+1, len(train_loader), loss.item()))

保存预训练的 teacher 网络权重为 pth 文件
torch.save(teacher_net.state_dict(), 'teacher_net.pth')
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
from torch.utils.data import DataLoader,Dataset
from torchvision.datasets import ImageFolder
import pandas as pd
import os
from PIL import Image

Define hyperparameters
batch_size = 64
num_epochs = 10
lr = 0.0001

device = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')

train_transforms=transforms.Compose([
transforms.Resize((256, 256)),
transforms.CenterCrop((256, 256)),
transforms.ToTensor(),
transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])

Custom dataset class
class CustomDataset(Dataset):
def init(self, csv_file, root_dir, transform=None):
self.annotations = pd.read_csv(csv_file)
self.root_dir = root_dir
self.transform = transform
self.annotations.iloc[:,1] = self.annotations.iloc[:,1].apply(lambda x:0 if x == -1 else x)

stylus
Copy
def __len__(self):
    return len(self.annotations)

def __getitem__(self, index):
    img_path = os.path.join(self.root_dir, self.annotations.iloc[index, 0])
    image = Image.open(img_path).convert('RGB')
    label = self.annotations.iloc[index, 1]
    if self.transform:
        image = self.transform(image)

    return image, label
Load custom dataset
train_dataset = CustomDataset(csv_file='/home/DataBase1/jyp/mini-imagenet/trainall.csv', root_dir='/home/DataBase1/jyp/mini-imagenet/images/', transform=train_transforms)

定义数据集
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True, num_workers=4)

定义 teacher 网络
class TeacherNet(nn.Module):
def init(self):
super(TeacherNet, self).init()
self.conv1 = nn.Conv2d(3, 128, kernel_size=4, stride=1, padding=3)
self.pool1 = nn.AvgPool2d(kernel_size=2, stride=2, padding=1)
self.conv2 = nn.Conv2d(128, 256, kernel_size=4, stride=1, padding=3)
self.pool2 = nn.AvgPool2d(kernel_size=2, stride=2, padding=1)
self.conv3 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)
self.conv4 = nn.Conv2d(256, 384, kernel_size=4, stride=1)
self.pool3 = nn.AdaptiveAvgPool2d((1,1))
self.fc = nn.Linear(384,19)
def forward(self, x):
x = nn.functional.relu(self.conv1(x))
x = self.pool1(x)
x = nn.functional.relu(self.conv2(x))
x = self.pool2(x)
x = nn.functional.relu(self.conv3(x))
x = self.conv4(x)
x = self.pool3(x)
x = x.view(x.size(0),-1)
x = self.fc(x)
#print(x.size())
return x

定义优化器和损失函数
teacher_net = TeacherNet()
teacher_net = teacher_net.to(device)

optimizer = optim.Adam(teacher_net.parameters(), lr=lr,weight_decay=0.00001)
criterion = nn.CrossEntropyLoss()
#criterion = nn.functional.mse_loss()

数据集上训练 teacher 网络
for epoch in range(num_epochs):
for i, (images, labels) in enumerate(train_loader):
images = images.to(device)
labels = labels.to(device)
optimizer.zero_grad()
outputs = teacher_net(images)
#print(outputs.size(), labels.size())
loss = criterion(outputs.view(-1,19),labels.view(-1))
loss.backward()
optimizer.step()
if (i+1) % 100 == 0:
print('Epoch [{}/{}], Step [{}/{}], Loss: {:.8f}'.format(epoch+1, num_epochs, i+1, len(train_loader), loss.item()))

保存预训练的 teacher 网络权重为 pth 文件
torch.save(teacher_net.state_dict(), 'teacher_net.pth')
